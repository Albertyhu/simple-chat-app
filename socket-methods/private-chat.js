const {
  convertUserMapToArray,
  removeFromMap,
  getNameById,
  createArrayOfUsers,
  isUsernameUnique,
} = require("../hooks/array.js"); 

const ReceiveInvite = ({io, socket, ExistingSession, messageStore})=>{
  //socket instence for when a someone once to send an invite 
  socket.on("chat-invite", (invite) => {
    const {
        inviter_name, 
        //session id of inviter
        inviter,
        //session id of invitee 
        invitee,
        roomKey,
    } = invite; 
    //if there isn't an existing chat history between parties, use the key generated by the client 
    let room_key = roomKey;
    const membersArr = []; 
    membersArr.push(inviter)
    membersArr.push(invitee)
    let foundKey = messageStore.doesChatAlreadyExist(membersArr)
    if(foundKey){
      room_key = foundKey; 
      invite.messages = messageStore.getChatHistoryById(foundKey)
    }
    else{
      messageStore.createStorage(roomKey, membersArr)
    }
    socket.join(`room-${room_key}`)
    var inviteeSocket = ExistingSession.getUserSocketId(invitee);     
    //The variable 'invitee' is the socket id that is unique to the user.
    socket.to(inviteeSocket).emit(`invited-to-chat`, invite);
  });
}

const ReceiveAcceptanceToInvite = ({socket})=>{
  socket.on("accept-private-chat-invite", (roomKey)=>{
    socket.join(`room-${roomKey}`)
  })  
}

//The reason that private doesn't work after a user refreshes is because roomKey originates from the client is not saved in server
const ReceiveJoinedPrivateChat = ({io, socket, ExistingSession, messageStore})=>{
  //notifies the server when a user joins a private chat room
  /**type event ={
   * username: string,
   * id: string, 
   * roomKey: string
   * }
  */
  socket.on("joined-private-chat", (event)=>{
    const chatItem = {
      username: null, 
      msg: `${event.username} has joined the private chat room.`, 
      roomKey: event.roomKey, 
      authorSocketId: socket.id,      
    }
    //send chat history to client 
    //This is flawed because the client may not be ready to receive the broadcasted message. 
    var chatHistory = messageStore.getChatHistoryById(event.roomKey); 
    if(chatHistory){
      socket.to(socket.id).emit(`room-${event.roomKey}-chat-history`, chatHistory)
    }

    //broadcast message to the chat room 
    socket.emit(`room-${event.roomKey}`, chatItem)
    messageStore.updateUserStatus(event.roomKey, event.id, true);
    //updates the number of users in the chat room; 

    var UsersInChat = ExistingSession.FormatArrayOfUsers(messageStore.getUserFromRoom(event.roomKey)); 
    io.emit(`update-list-in-room-${event.roomKey}`, UsersInChat);  
  })  
}

//When a user submits a message in chat
const ReceivePrivateChat =({io, socket, messageStore})=>{
  socket.on("private-message", (event)=>{
    const {
      username, 
      msg, 
      roomKey, 
      id, 
      date, 
    } = event; 
    io.emit(`room-${roomKey}`, event)
    console.log("date: ", date)
    messageStore.saveMessages(roomKey, username, id, msg, date)
  })
}

  //when a user is typing in specific private chat room 
const ReceiveTypingInPrivateChat = ({io, socket}) =>{
  socket.on(`typing private chat`, (event)=>{
    const {
        roomKey,
        id
    } = event; 
    io.emit(`user is typing-${roomKey}`, id)
  })
}
//when a user is no longer typing in specific private chat room 
const ReceiveStopTypingInPrivateChat = ({io, socket}) =>{
  socket.on(`no longer typing in private chat`, (event)=>{
    const {
      roomKey,
      id, 
    } = event; 
    io.emit(`no longer typing-${roomKey}`, id)
  })
}

module.exports = {
    ReceiveInvite, 
    ReceiveAcceptanceToInvite, 
    ReceiveJoinedPrivateChat,
    ReceivePrivateChat, 
    ReceiveTypingInPrivateChat, 
    ReceiveStopTypingInPrivateChat 
}