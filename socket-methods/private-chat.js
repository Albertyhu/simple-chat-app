const {
  printSocketRooms, 
} = require("../hooks/array.js"); 

const {
  UpdateUserChatRoomList, 
  ChooseWhosClientListToUpdate,  
} = require("./shared-methods.js"); 

const ReceiveInvite = ({io, socket, ExistingSession, messageStore})=>{
  //socket instence for when a someone once to send an invite 
  socket.on("chat-invite", (invite) => {
    const {
        inviter_name, 
        //session id of inviter
        inviter,
        //session id of invitee 
        invitee,
        roomKey,
    } = invite; 
    invite.time = new Date(); 
    //if there isn't an existing chat history between parties, use the key generated by the client 
    let room_key = roomKey;
    const membersArr = []; 
    membersArr.push(inviter)
    membersArr.push(invitee)
    let foundKey = messageStore.doesChatAlreadyExist(membersArr)
    if(foundKey){
      room_key = foundKey; 
      invite.messages = messageStore.getChatHistoryById(foundKey)
    }
    else{
      messageStore.createStorage(roomKey, [])
    }
    socket.join(`room-${room_key}`)
    console.log("receive invite messageStore keys: ", messageStore.storage.keys())
    var inviteeSocket = ExistingSession.getUserSocketId(invitee);     
    //The variable 'invitee' is the socket id that is unique to the user.
    socket.to(inviteeSocket).emit(`invited-to-chat`, invite);
  });
}

const ReceiveAcceptanceToInvite = ({socket})=>{
  socket.on("accept-private-chat-invite", (roomKey)=>{
    socket.join(`room-${roomKey}`)
  })  
}

//The reason that private doesn't work after a user refreshes is because roomKey originates from the client is not saved in server
const ReceiveJoinedPrivateChat = ({io, socket, ExistingSession, messageStore})=>{
  //notifies the server when a user joins a private chat room
  socket.on("joined-private-chat", (event)=>{
    const {
      roomKey, 
      username, 
      id, 
    } = event; 
    /**type event ={
     * username: string,
     * id: string, 
     * roomKey: string
     * }
    */
    const chatItem = {
      username: null, 
      msg: `${username} has joined the private chat room.`, 
      roomKey: roomKey, 
      socketId: socket.id,       
    }
    //check to see if the user is previously offline, which means he is not in any chat rooms 
    //the function checks the chat rooms for any of the user's sockets. 
    //This has to be done before the user is added to messageStore
    let wasOffline = !messageStore.isUserOnline(id)

    //broadcast message to the chat room 
    io.emit(`room-${roomKey}`, chatItem)

    //add user to storage
    messageStore.addUserToRoom(roomKey, id, socket.id, true)
    ///messageStore.updateUserStatus(roomKey, id, true);
    //updates the number of users in the chat room; 
    //printSocketRooms(socket, username)
    messageStore.saveUserSocket(roomKey, id, socket.id)

    //update the chat rooms that the sure is in 
    //Broadcast to other users who are in the same chatroom
    UpdateUserChatRoomList(socket, username, id, ExistingSession, messageStore, roomKey);

    //Choose between updating everyone's list of online users or just the current user's 
    ChooseWhosClientListToUpdate({wasOffline, io, socket, ExistingSession, messageStore})
  })  
}

//When a user submits a message in chat
const ReceivePrivateChat =({io, socket, messageStore})=>{
  socket.on("private-message", (event)=>{
    const {
      username, 
      msg, 
      roomKey, 
      id, 
      date, 
    } = event; 
    io.emit(`room-${roomKey}`, event)
    messageStore.saveMessages(roomKey, username, id, msg, date)
  })
}

  //when a user is typing in specific private chat room 
const ReceiveTypingInPrivateChat = ({io, socket}) =>{
  socket.on(`typing private chat`, (event)=>{
    const {
        roomKey,
        id
    } = event; 
    io.emit(`user is typing-${roomKey}`, id)
  })
}
//when a user is no longer typing in specific private chat room 
const ReceiveStopTypingInPrivateChat = ({io, socket}) =>{
  socket.on(`no longer typing in private chat`, (event)=>{
    const {
      roomKey,
      id, 
    } = event; 
    io.emit(`no longer typing-${roomKey}`, id)
  })
}

module.exports = {
    ReceiveInvite, 
    ReceiveAcceptanceToInvite, 
    ReceiveJoinedPrivateChat,
    ReceivePrivateChat, 
    ReceiveTypingInPrivateChat, 
    ReceiveStopTypingInPrivateChat 
}