const {
  convertUserMapToArray,
  removeFromMap,
  getNameById,
  createArrayOfUsers,
  isUsernameUnique,
} = require("../hooks/array.js"); 

const ReceiveInvite = ({io, socket, ExistingSession, messageStore})=>{
  //socket instence for when a someone once to send an invite 
  socket.on("chat-invite", (invite) => {
    const {
        inviter_name, 
        //session id of inviter
        inviter,
        //session id of invitee 
        invitee,
        roomKey,
    } = invite; 
    //if there isn't an existing chat history between parties, use the key generated by the client 
    let room_key = roomKey;
    console.log("ReceiveInvite roomKey: ", roomKey) 
    const membersArr = []; 
    membersArr.push(inviter)
    membersArr.push(invitee)
    let foundKey = messageStore.doesChatAlreadyExist(membersArr)
    if(foundKey){
      room_key = foundKey; 
      invite.messages = messageStore.getChatHistoryById(foundKey)
    }
    else{
      messageStore.createStorage(roomKey, membersArr)
    }
    socket.join(`room-${room_key}`)
    var inviteeSocket = ExistingSession.getUserSocketId(invitee);     
    //The variable 'invitee' is the socket id that is unique to the user.
    socket.to(inviteeSocket).emit(`invited-to-chat`, invite);
  });
}

//The reason that private doesn't work after a user refreshes is because roomKey originates from the client is not saved in server
const ReceiveJoinedPrivateChat = ({io, socket, ExistingSession, messageStore})=>{
  //notifies the server when a user joins a private chat room
  socket.on("joined-private-chat", async (event)=>{
    console.log(`${event.username} just joined`)
    const chatItem = {
      username: null, 
      msg: `${event.username} has joined the private chat room.`, 
      roomKey: event.roomKey, 
      authorSocketId: socket.id,      
    }
    //send chat history to client 
    var chatHistory = messageStore.getChatHistoryById(event.roomKey); 
    if(chatHistory){
      socket.to(socket.id).emit(`room-${event.roomKey}-chat-history`, chatHistory)
    }

    //broadcast message to the chat room 
    socket.emit(`room-${event.roomKey}`, chatItem)

    //updates the number of users in the chat room; 
    //This returns a set of socket.id. createArrayOfUsers is not adapted to this problem.
    const Ids = io.sockets.adapter.rooms.get(`room-${event.roomKey}`);
    console.log("Ids: ", Ids)
    console.log("typeof Ids: ", typeof Ids)
    const UsersInChat = createArrayOfUsers(Ids, ExistingSession.returnAllSession())
    //var updatedList = ExistingSession.returnAllSessionsAsArray()
    const matchingSockets = await io.in(socket.id).allSockets();

    socket.emit(`update-list-in-room-${event.roomKey}`, UsersInChat);  
  })  
}

const ReceivePrivateChat =({io, socket, messageStore})=>{
  socket.on("private-message", (event)=>{
    const {
      username, 
      msg, 
      roomKey, 
      id, 
      date, 
    } = event; 
    console.log("event: ", event)
    io.emit(`room-${roomKey}`, event)
    messageStore.saveMessages(roomKey, username, id, msg, date)
  })
}

  //when a user is typing in specific private chat room 
const ReceiveTypingInPrivateChat = ({io, socket}) =>{
  socket.on(`typing private chat`, (event)=>{
    const {
        roomKey,
        id
    } = event; 
    io.emit(`user is typing-${roomKey}`, id)
  })
}
//when a user is no longer typing in specific private chat room 
const ReceiveStopTypingInPrivateChat = ({io, socket}) =>{
  socket.on(`no longer typing in private chat`, (event)=>{
    const {
      roomKey,
      id, 
    } = event; 
    io.emit(`no longer typing-${roomKey}`, id)
  })
}

module.exports = {
    ReceiveInvite, 
    ReceiveJoinedPrivateChat,
    ReceivePrivateChat, 
    ReceiveTypingInPrivateChat, 
    ReceiveStopTypingInPrivateChat 
}